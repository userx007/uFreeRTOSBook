# Hardware Timer Integration in FreeRTOS

## Overview

Hardware timer integration is fundamental to FreeRTOS operation. The RTOS kernel requires a periodic interrupt (system tick) to manage task scheduling, time delays, and timeouts. Additionally, hardware timers enable precise timing operations beyond what software timers can provide.

## System Tick Generation

The system tick is the heartbeat of FreeRTOS, typically generated by a hardware timer interrupt occurring at regular intervals (commonly 1ms).

### Configuration

The tick rate is configured in `FreeRTOSConfig.h`:

```c
#define configTICK_RATE_HZ          1000    // 1ms tick period
#define configCPU_CLOCK_HZ          80000000 // 80 MHz CPU
```

### Basic System Tick Implementation (ARM Cortex-M)

```c
#include "FreeRTOS.h"
#include "task.h"

// SysTick timer configuration for ARM Cortex-M
void vPortSetupTimerInterrupt(void)
{
    // Configure SysTick to generate interrupt at tick rate
    const uint32_t ulReloadValue = (configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    
    // Set reload register
    SysTick->LOAD = ulReloadValue;
    
    // Reset counter value
    SysTick->VAL = 0UL;
    
    // Enable SysTick, use processor clock, enable interrupt
    SysTick->CTRL = (1UL << 2) | (1UL << 1) | (1UL << 0);
}

// SysTick interrupt handler
void SysTick_Handler(void)
{
    // Increment tick count and perform context switch if needed
    if (xTaskIncrementTick() != pdFALSE)
    {
        // Request context switch
        portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    }
}
```

## Using Hardware Timers for Precise Timing

Hardware timers provide microsecond-level precision, essential for applications requiring accurate timing beyond the system tick resolution.

### Example: ESP32 Hardware Timer for Precise Control

```c
#include "FreeRTOS.h"
#include "task.h"
#include "driver/timer.h"
#include "semphr.h"

#define TIMER_GROUP     TIMER_GROUP_0
#define TIMER_INDEX     TIMER_0
#define TIMER_INTERVAL_US 100  // 100 microseconds

static SemaphoreHandle_t xTimerSemaphore = NULL;
static volatile uint32_t ulTimerCounter = 0;

// Timer interrupt handler
void IRAM_ATTR timer_group0_isr(void *para)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    // Clear interrupt flag
    timer_group_clr_intr_status_in_isr(TIMER_GROUP, TIMER_INDEX);
    
    // Re-enable alarm
    timer_group_enable_alarm_in_isr(TIMER_GROUP, TIMER_INDEX);
    
    ulTimerCounter++;
    
    // Signal task from ISR
    xSemaphoreGiveFromISR(xTimerSemaphore, &xHigherPriorityTaskWoken);
    
    // Request context switch if needed
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

// Initialize hardware timer
void vInitHardwareTimer(void)
{
    timer_config_t config = {
        .divider = 80,                          // 80 MHz / 80 = 1 MHz (1 us per tick)
        .counter_dir = TIMER_COUNT_UP,
        .counter_en = TIMER_PAUSE,
        .alarm_en = TIMER_ALARM_EN,
        .auto_reload = TIMER_AUTORELOAD_EN,
    };
    
    timer_init(TIMER_GROUP, TIMER_INDEX, &config);
    timer_set_counter_value(TIMER_GROUP, TIMER_INDEX, 0);
    timer_set_alarm_value(TIMER_GROUP, TIMER_INDEX, TIMER_INTERVAL_US);
    timer_enable_intr(TIMER_GROUP, TIMER_INDEX);
    timer_isr_register(TIMER_GROUP, TIMER_INDEX, timer_group0_isr, NULL, ESP_INTR_FLAG_IRAM, NULL);
    timer_start(TIMER_GROUP, TIMER_INDEX);
}

// Task that waits for timer events
void vPreciseTimingTask(void *pvParameters)
{
    uint32_t ulLastCount = 0;
    
    while (1)
    {
        // Wait for timer signal (with timeout)
        if (xSemaphoreTake(xTimerSemaphore, pdMS_TO_TICKS(1000)) == pdTRUE)
        {
            uint32_t ulCurrentCount = ulTimerCounter;
            uint32_t ulElapsed = ulCurrentCount - ulLastCount;
            
            // Perform precise timing operation
            printf("Timer fired: Count=%lu, Elapsed=%lu\n", 
                   ulCurrentCount, ulElapsed);
            
            ulLastCount = ulCurrentCount;
        }
    }
}
```

### Example: STM32 Hardware Timer for PWM Generation

```c
#include "FreeRTOS.h"
#include "task.h"
#include "stm32f4xx_hal.h"

TIM_HandleTypeDef htim2;
static volatile uint16_t usDutyCycle = 500; // 50% duty cycle

// Configure hardware timer for PWM
void vInitPWMTimer(void)
{
    TIM_OC_InitTypeDef sConfigOC = {0};
    
    // Timer base configuration
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 84 - 1;          // 84 MHz / 84 = 1 MHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 1000 - 1;           // 1 kHz PWM frequency
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_PWM_Init(&htim2);
    
    // PWM channel configuration
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = usDutyCycle;
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
    
    // Start PWM
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
}

// Task to dynamically adjust PWM duty cycle
void vPWMControlTask(void *pvParameters)
{
    uint16_t usTargetDutyCycle = 0;
    
    while (1)
    {
        // Gradually increase duty cycle from 0% to 100%
        for (usTargetDutyCycle = 0; usTargetDutyCycle <= 1000; usTargetDutyCycle += 10)
        {
            taskENTER_CRITICAL();
            usDutyCycle = usTargetDutyCycle;
            __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, usDutyCycle);
            taskEXIT_CRITICAL();
            
            vTaskDelay(pdMS_TO_TICKS(50));
        }
        
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

## Advanced Timer Integration Example: Multi-Channel Input Capture

This example demonstrates using hardware timers for precise input capture, useful for measuring pulse widths or frequencies.

```c
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "stm32f4xx_hal.h"

#define CAPTURE_QUEUE_LENGTH 10

typedef struct
{
    uint32_t ulCaptureValue;
    uint32_t ulTimestamp;
} CaptureData_t;

TIM_HandleTypeDef htim3;
static QueueHandle_t xCaptureQueue = NULL;
static volatile uint32_t ulLastCapture = 0;
static volatile uint32_t ulOverflowCount = 0;

// Timer overflow interrupt handler
void TIM3_IRQHandler(void)
{
    if (__HAL_TIM_GET_FLAG(&htim3, TIM_FLAG_UPDATE) != RESET)
    {
        if (__HAL_TIM_GET_IT_SOURCE(&htim3, TIM_IT_UPDATE) != RESET)
        {
            __HAL_TIM_CLEAR_IT(&htim3, TIM_IT_UPDATE);
            ulOverflowCount++;
        }
    }
    
    // Input capture interrupt
    if (__HAL_TIM_GET_FLAG(&htim3, TIM_FLAG_CC1) != RESET)
    {
        if (__HAL_TIM_GET_IT_SOURCE(&htim3, TIM_IT_CC1) != RESET)
        {
            __HAL_TIM_CLEAR_IT(&htim3, TIM_IT_CC1);
            
            uint32_t ulCaptureValue = HAL_TIM_ReadCapturedValue(&htim3, TIM_CHANNEL_1);
            uint32_t ulPulseWidth = ulCaptureValue - ulLastCapture;
            ulLastCapture = ulCaptureValue;
            
            CaptureData_t xData;
            xData.ulCaptureValue = ulPulseWidth;
            xData.ulTimestamp = xTaskGetTickCountFromISR();
            
            BaseType_t xHigherPriorityTaskWoken = pdFALSE;
            xQueueSendFromISR(xCaptureQueue, &xData, &xHigherPriorityTaskWoken);
            portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
        }
    }
}

// Initialize input capture timer
void vInitInputCaptureTimer(void)
{
    TIM_IC_InitTypeDef sConfigIC = {0};
    
    // Timer configuration for input capture
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = 84 - 1;          // 1 MHz timer clock
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 0xFFFF;             // Maximum period
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_IC_Init(&htim3);
    
    // Input capture channel configuration
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
    sConfigIC.ICFilter = 0;
    HAL_TIM_IC_ConfigChannel(&htim3, &sConfigIC, TIM_CHANNEL_1);
    
    // Enable interrupts
    HAL_NVIC_SetPriority(TIM3_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
    
    // Start input capture with interrupt
    HAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_1);
    __HAL_TIM_ENABLE_IT(&htim3, TIM_IT_UPDATE);
}

// Task to process captured data
void vInputCaptureTask(void *pvParameters)
{
    CaptureData_t xReceivedData;
    
    while (1)
    {
        if (xQueueReceive(xCaptureQueue, &xReceivedData, portMAX_DELAY) == pdTRUE)
        {
            // Convert to microseconds (assuming 1 MHz timer)
            float fPulseWidthUs = (float)xReceivedData.ulCaptureValue;
            float fFrequencyHz = 1000000.0f / fPulseWidthUs;
            
            printf("Pulse Width: %.2f us, Frequency: %.2f Hz\n", 
                   fPulseWidthUs, fFrequencyHz);
        }
    }
}
```

## Practical Application: Data Acquisition System

Here's a complete example combining multiple timer functionalities for a data acquisition system:

```c
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

#define ADC_SAMPLE_RATE_HZ  1000    // 1 kHz sampling
#define NUM_CHANNELS        4

typedef struct
{
    uint16_t usAdcValues[NUM_CHANNELS];
    TickType_t xTimestamp;
    uint32_t ulSampleNumber;
} AdcSample_t;

static QueueHandle_t xAdcQueue = NULL;
static SemaphoreHandle_t xAdcSemaphore = NULL;
static volatile uint32_t ulSampleCounter = 0;

// High-priority timer ISR for ADC triggering
void IRAM_ATTR adc_timer_isr(void *arg)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    // Clear timer interrupt
    timer_group_clr_intr_status_in_isr(TIMER_GROUP_0, TIMER_0);
    timer_group_enable_alarm_in_isr(TIMER_GROUP_0, TIMER_0);
    
    ulSampleCounter++;
    
    // Trigger ADC conversion (actual implementation depends on hardware)
    // START_ADC_CONVERSION();
    
    // Signal processing task
    xSemaphoreGiveFromISR(xAdcSemaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

// Initialize acquisition timer
void vInitAcquisitionTimer(void)
{
    timer_config_t config = {
        .divider = 80,                      // 1 MHz
        .counter_dir = TIMER_COUNT_UP,
        .counter_en = TIMER_PAUSE,
        .alarm_en = TIMER_ALARM_EN,
        .auto_reload = TIMER_AUTORELOAD_EN,
    };
    
    uint32_t ulTimerInterval = 1000000 / ADC_SAMPLE_RATE_HZ;
    
    timer_init(TIMER_GROUP_0, TIMER_0, &config);
    timer_set_counter_value(TIMER_GROUP_0, TIMER_0, 0);
    timer_set_alarm_value(TIMER_GROUP_0, TIMER_0, ulTimerInterval);
    timer_enable_intr(TIMER_GROUP_0, TIMER_0);
    timer_isr_register(TIMER_GROUP_0, TIMER_0, adc_timer_isr, NULL, 
                      ESP_INTR_FLAG_IRAM, NULL);
    timer_start(TIMER_GROUP_0, TIMER_0);
}

// High-priority task for data acquisition
void vDataAcquisitionTask(void *pvParameters)
{
    AdcSample_t xSample;
    
    // Set high priority for real-time acquisition
    vTaskPrioritySet(NULL, configMAX_PRIORITIES - 1);
    
    while (1)
    {
        if (xSemaphoreTake(xAdcSemaphore, pdMS_TO_TICKS(100)) == pdTRUE)
        {
            // Read ADC values (actual implementation depends on hardware)
            for (int i = 0; i < NUM_CHANNELS; i++)
            {
                // xSample.usAdcValues[i] = READ_ADC_CHANNEL(i);
                xSample.usAdcValues[i] = (uint16_t)(rand() % 4096); // Simulated
            }
            
            xSample.xTimestamp = xTaskGetTickCount();
            xSample.ulSampleNumber = ulSampleCounter;
            
            // Send to processing queue (non-blocking to avoid missing samples)
            xQueueSend(xAdcQueue, &xSample, 0);
        }
    }
}

// Lower priority task for data processing
void vDataProcessingTask(void *pvParameters)
{
    AdcSample_t xReceivedSample;
    float fRunningAverage[NUM_CHANNELS] = {0};
    const float fAlpha = 0.1f; // Filter coefficient
    
    while (1)
    {
        if (xQueueReceive(xAdcQueue, &xReceivedSample, portMAX_DELAY) == pdTRUE)
        {
            // Apply low-pass filter
            for (int i = 0; i < NUM_CHANNELS; i++)
            {
                fRunningAverage[i] = fAlpha * xReceivedSample.usAdcValues[i] + 
                                     (1.0f - fAlpha) * fRunningAverage[i];
            }
            
            // Process every 100th sample
            if (xReceivedSample.ulSampleNumber % 100 == 0)
            {
                printf("Sample #%lu: ", xReceivedSample.ulSampleNumber);
                for (int i = 0; i < NUM_CHANNELS; i++)
                {
                    printf("CH%d=%.1f ", i, fRunningAverage[i]);
                }
                printf("\n");
            }
        }
    }
}

// Application entry point
void app_main(void)
{
    // Create synchronization objects
    xAdcQueue = xQueueCreate(100, sizeof(AdcSample_t));
    xAdcSemaphore = xSemaphoreCreateBinary();
    
    // Initialize hardware timer
    vInitAcquisitionTimer();
    
    // Create tasks
    xTaskCreate(vDataAcquisitionTask, "ADC_Task", 2048, NULL, 
                configMAX_PRIORITIES - 1, NULL);
    xTaskCreate(vDataProcessingTask, "Process_Task", 4096, NULL, 
                tskIDLE_PRIORITY + 2, NULL);
}
```

## Best Practices

**Interrupt Priority Management**: Configure timer interrupts with appropriate priorities relative to the system tick and other interrupts. The system tick should typically have lower priority than critical hardware timers.

**Critical Sections**: Use `taskENTER_CRITICAL()` and `taskEXIT_CRITICAL()` when accessing shared variables between ISRs and tasks.

**ISR Safety**: Only use FreeRTOS API functions ending in `FromISR` within interrupt handlers, and always check for required context switches.

**Timer Resolution**: Choose timer prescalers carefully to balance resolution and maximum timing period based on your application requirements.

**Overflow Handling**: For long-duration measurements, implement overflow counters to extend the effective timer range.

Hardware timer integration enables FreeRTOS to meet real-time requirements while providing precise timing control for demanding embedded applications.